# Assembly Analysis Guide for SIMD Vectorization

This guide helps you understand how to interpret the assembly output generated by the compiler when using SIMD vectorization, particularly with OpenMP SIMD directives.

## Table of Contents

1. [Introduction](#introduction)
2. [Generating Assembly Output](#generating-assembly-output)
3. [SIMD Instruction Sets](#simd-instruction-sets)
4. [Identifying Vectorized Code](#identifying-vectorized-code)
5. [Common Assembly Patterns](#common-assembly-patterns)
6. [Missed Vectorization Opportunities](#missed-vectorization-opportunities)
7. [Assembly Analysis Examples](#assembly-analysis-examples)

---

## Introduction

Examining assembly output is the most reliable way to determine if your code has been successfully vectorized. This guide will help you understand:

- How to generate and read assembly output
- How to identify SIMD instructions in assembly
- How to spot missed vectorization opportunities
- How to improve your code based on assembly analysis

---

## Generating Assembly Output

There are several ways to generate assembly output from your C++ code with MSVC (Microsoft Visual C++):

### Using the MSVC Compiler Directly

```bash
cl.exe /c /FA /O2 /openmp your_file.cpp
```

The `/FA` flag generates an assembly listing file (.asm).

### Using Our Script

The project includes a script to generate assembly output:

```bash
generate_asm_report.bat
```

This script will:
1. Compile your code with and without vectorization
2. Generate annotated assembly files in the `asm_output` directory
3. Highlight SIMD instructions for easy identification

### Reading the Output

Assembly files (.asm) can be opened with any text editor, but you can use the built-in assembly analyzer in this project:

```bash
build\Release\OpenMP_SIMD_Vectorization.exe --asm-analysis
```

This will provide a user-friendly analysis of the assembly output.

---

## SIMD Instruction Sets

To understand vectorized assembly, you need to recognize SIMD instructions for different instruction sets:

### SSE Instruction Naming Patterns

SSE instructions typically start with:
- `movaps`, `movups`: Move aligned/unaligned packed single-precision
- `addps`, `subps`, `mulps`, `divps`: Arithmetic on packed single-precision
- `movapd`, `movupd`: Move aligned/unaligned packed double-precision (SSE2)
- `addpd`, `subpd`, `mulpd`, `divpd`: Arithmetic on packed double-precision (SSE2)

Example:
```assembly
movaps      xmm0, XMMWORD PTR [rax]    ; Load 4 floats into xmm0
addps       xmm0, XMMWORD PTR [rcx]    ; Add 4 floats from rcx to xmm0
movaps      XMMWORD PTR [rdx], xmm0    ; Store result (4 floats) to rdx
```

### AVX Instruction Naming Patterns

AVX instructions typically start with 'v' followed by the operation:
- `vmovaps`, `vmovups`: AVX versions of SSE move instructions
- `vaddps`, `vsubps`, `vmulps`, `vdivps`: AVX arithmetic operations
- `vfmadd132ps`, `vfmadd213ps`, `vfmadd231ps`: Fused multiply-add (AVX2)

Example:
```assembly
vmovaps     ymm0, YMMWORD PTR [rax]    ; Load 8 floats into ymm0
vaddps      ymm0, ymm0, YMMWORD PTR [rcx] ; Add 8 floats from rcx to ymm0
vmovaps     YMMWORD PTR [rdx], ymm0    ; Store result (8 floats) to rdx
```

### SIMD Register Usage

The width of the register indicates the SIMD width being used:
- `xmm0`-`xmm15`: 128-bit SSE registers (can hold 4 floats or 2 doubles)
- `ymm0`-`ymm15`: 256-bit AVX registers (can hold 8 floats or 4 doubles)
- `zmm0`-`zmm31`: 512-bit AVX-512 registers (can hold 16 floats or 8 doubles)

---

## Identifying Vectorized Code

### Key Indicators of Vectorization

1. **SIMD Register Usage**  
   Look for `xmm`, `ymm`, or `zmm` registers in the assembly.

2. **Vector Instructions**  
   Instructions like `addps`, `mulps`, `vaddps`, `vmulps`, etc.

3. **Loop Structure**  
   Fewer iterations in the main loop, with each iteration processing multiple elements.

4. **Alignment Checks**  
   Code that checks for memory alignment before the main loop.

5. **Remainder Loops**  
   Small loops after the main vectorized loop to handle elements that don't fit into vector width.

### Example: Vectorized Loop vs. Non-Vectorized Loop

Non-vectorized:
```assembly
; Loop processes one element per iteration
.loop:
    movss       xmm0, DWORD PTR [rax+rcx*4]
    addss       xmm0, DWORD PTR [rdx+rcx*4]
    movss       DWORD PTR [r8+rcx*4], xmm0
    inc         rcx
    cmp         rcx, r9
    jb          .loop
```

Vectorized:
```assembly
; Loop processes 8 elements per iteration (AVX)
.loop:
    vmovups     ymm0, YMMWORD PTR [rax+rcx*4]
    vaddps      ymm0, ymm0, YMMWORD PTR [rdx+rcx*4]
    vmovups     YMMWORD PTR [r8+rcx*4], ymm0
    add         rcx, 8
    cmp         rcx, r9
    jb          .loop
```

---

## Common Assembly Patterns

Here are common patterns you'll see in vectorized assembly:

### 1. Alignment Check and Path Selection

The compiler often creates multiple paths: one for aligned data and one for unaligned or for the remainder loop.

```assembly
; Check if pointer is aligned to 32-byte boundary (for AVX)
test        rax, 31
jnz         .unaligned_path
```

### 2. Vector Loop Setup

Setting up the vector loop often involves initializing loop counters and calculating the number of vector iterations.

```assembly
; Calculate number of vector iterations (process 8 elements per iteration)
mov         rcx, rdx
shr         rcx, 3          ; Divide by 8
jz          .remainder      ; If zero, skip to remainder
```

### 3. Main Vector Loop

The main loop processes multiple elements at once using SIMD instructions.

```assembly
.vector_loop:
    vmovups     ymm0, YMMWORD PTR [rax+r8]
    vmovups     ymm1, YMMWORD PTR [rax+r8+32]
    vmulps      ymm0, ymm0, ymm2
    vmulps      ymm1, ymm1, ymm2
    vmovups     YMMWORD PTR [rcx+r8], ymm0
    vmovups     YMMWORD PTR [rcx+r8+32], ymm1
    add         r8, 64
    sub         rdx, 16
    jnz         .vector_loop
```

### 4. Remainder Loop

After the vectorized loop, there's often a scalar loop to handle remaining elements.

```assembly
.remainder:
    test        r9, r9
    jz          .done
.scalar_loop:
    movss       xmm0, DWORD PTR [rax+r8]
    mulss       xmm0, xmm2
    movss       DWORD PTR [rcx+r8], xmm0
    add         r8, 4
    dec         r9
    jnz         .scalar_loop
.done:
```

---

## Missed Vectorization Opportunities

When analyzing assembly, look for these signs that vectorization failed:

### 1. Scalar Instructions Only

If you see only scalar instructions like `addss`, `mulss` (single element operations) instead of `addps`, `mulps` (packed operations), vectorization likely failed.

### 2. No SIMD Register Usage

If the code only uses general-purpose registers (`rax`, `rbx`, etc.) and not SIMD registers (`xmm`, `ymm`, `zmm`), vectorization failed.

### 3. Original Loop Count Preserved

If the loop iterates exactly the same number of times as your source loop (rather than processing multiple elements per iteration), vectorization didn't happen.

### 4. Function Calls Inside Loops

Function calls often prevent vectorization. Look for `call` instructions inside loops.

### 5. Complex Control Flow

Multiple branches (`jcc` instructions) within a loop often indicate vectorization failure.

---

## Assembly Analysis Examples

Let's look at some real examples and analyze them:

### Example 1: Successfully Vectorized Addition

Source code:
```cpp
#pragma omp simd
for (int i = 0; i < n; i++) {
    c[i] = a[i] + b[i];
}
```

Assembly output (AVX):
```assembly
; Calculate number of iterations for main vector loop
mov         rax, rcx
shr         rax, 3          ; Divide by 8 (process 8 floats at once)
jz          .remainder

; Main vectorized loop
.vector_loop:
    vmovups     ymm0, YMMWORD PTR [rdx+r8]     ; Load 8 elements from a
    vaddps      ymm0, ymm0, YMMWORD PTR [r9+r8] ; Add 8 elements from b
    vmovups     YMMWORD PTR [r10+r8], ymm0     ; Store 8 results to c
    add         r8, 32                         ; Advance pointer by 32 bytes
    dec         rax                            ; Decrement loop counter
    jnz         .vector_loop

; Handle remaining elements
.remainder:
    mov         rax, rcx
    and         rax, 7      ; Get remainder count (rcx mod 8)
    jz          .done       ; If no remainder, we're done

.scalar_loop:
    movss       xmm0, DWORD PTR [rdx+r8]       ; Load 1 element from a
    addss       xmm0, DWORD PTR [r9+r8]        ; Add 1 element from b
    movss       DWORD PTR [r10+r8], xmm0       ; Store 1 result to c
    add         r8, 4                          ; Advance pointer by 4 bytes
    dec         rax                            ; Decrement remainder counter
    jnz         .scalar_loop

.done:
```

**Analysis:** This is successfully vectorized. The main loop processes 8 elements at once using AVX instructions (`ymm` registers, `vmovups`, `vaddps`). The remainder loop handles elements that don't fit into the vector width.

### Example 2: Failed Vectorization Due to Dependencies

Source code:
```cpp
for (int i = 1; i < n; i++) {
    a[i] = a[i-1] * 0.5f;  // Loop-carried dependency
}
```

Assembly output:
```assembly
; Initialize loop
xor         eax, eax
inc         eax
movss       xmm0, DWORD PTR .LC0[rip]  ; Load 0.5f

.loop:
    movss       xmm1, DWORD PTR [rdx+rax*4-4] ; Load a[i-1]
    mulss       xmm1, xmm0                   ; Multiply by 0.5f
    movss       DWORD PTR [rdx+rax*4], xmm1  ; Store to a[i]
    inc         rax                          ; Increment loop counter
    cmp         rax, rcx                     ; Compare with n
    jl          .loop                        ; Continue if i < n
```

**Analysis:** Vectorization failed due to the loop-carried dependency. We see scalar instructions (`movss`, `mulss`) operating on single elements, and the loop processes one element per iteration.

---

By carefully analyzing assembly output, you can identify whether vectorization is successful and pinpoint specific areas for improvement in your code. The `generate_asm_report.bat` script and assembly analyzer in this project make this process much easier by automatically generating and annotating the assembly.